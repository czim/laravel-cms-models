<?php
namespace Czim\CmsModels\Http\Controllers\Traits;

use Czim\CmsModels\Contracts\ModelInformation\Data\ModelInformationInterface;
use Czim\CmsModels\Contracts\Strategies\DeleteConditionStrategyInterface;
use Illuminate\Database\Eloquent\Model;
use UnexpectedValueException;

trait ChecksModelDeletable
{

    /**
     * A (translated) message generated by the last unmet delete condition.
     *
     * @var null|string
     */
    protected $lastUnmetDeleteConditionMessage;

    /**
     * Returns whether a given model may be deleted.
     *
     * @param Model $model
     * @return bool
     */
    protected function isModelDeletable(Model $model)
    {
        $this->lastUnmetDeleteConditionMessage = null;

        // access rights
        if ( ! $this->isAuthorizedToDelete()) {
            $this->lastUnmetDeleteConditionMessage = $this->getUnmetConditionMessageForAuthorizationFailure();
            return false;
        }

        // delete condition & model configuration
        $info = $this->getModelInformation();

        if ( ! $info->allowDelete()) {
            $this->lastUnmetDeleteConditionMessage = $this->getUnmetConditionMessageForDisallowedFailure();
            return false;
        }

        $condition = $info->deleteCondition();

        if ( ! $condition) {
            return true;
        }

        // Resolve condition and check.
        $strategies = $this->interpretDeleteCondition($condition);

        foreach ($strategies as $strategy => $parameters) {

            /** @var DeleteConditionStrategyInterface $instance */
            $instance = app($strategy);

            if ( ! $instance->check($model, $parameters)) {
                $this->lastUnmetDeleteConditionMessage = $instance->message();
                return false;
            }
        }

        return true;
    }

    /**
     * Returns whether (current) user is allowed to delete a model.
     *
     * @return bool
     */
    protected function isAuthorizedToDelete()
    {
        return cms_auth()->can($this->getPermissionPrefix() . 'delete');
    }

    /**
     * Returns the failure display message for the previous delete condition check.
     *
     * @return null|string
     */
    protected function getLastUnmetDeleteConditionMessage()
    {
        return $this->lastUnmetDeleteConditionMessage;
    }

    /**
     * Interprets delete condition value and returns an array of delete condition classes
     *
     * @param $condition
     * @return array    associative: returns key-value pairs: 'strategy' => parameters
     */
    protected function interpretDeleteCondition($condition)
    {
        // Allow pipe symbol to split strategies
        if (false !== strpos($condition, '|')) {
            $condition = explode('|', $condition);
        }

        // Normalize arrays, handle each string condition separately
        if (is_array($condition)) {

            $normalized = [];

            foreach ($condition as $partialCondition) {

                $normalized = array_merge($normalized, $this->interpretDeleteCondition($partialCondition));
            }

            return $normalized;
        }

        // Split strategy & parameters
        if (false !== strpos($condition, ':')) {
            list($strategy, $parameters) = explode(':', $condition, 2);
            $parameters = explode(',', $parameters);
        } else {
            $strategy   = $condition;
            $parameters = [];
        }

        $strategy = $this->resolveDeleteConditionStrategyClass($strategy);

        return [ $strategy => $parameters ];
    }

    /**
     * Resolves strategy assuming it is the class name or FQN of a delete condition interface
     * implementation, or a configured alias.
     *
     * @param string $strategy
     * @return string|false     returns full class namespace if it was resolved succesfully
     */
    protected function resolveDeleteConditionStrategyClass($strategy)
    {
        $originalStrategy = $strategy;

        if ( ! str_contains($strategy, '.')) {
            $strategy = config('cms-models.strategies.delete.condition-aliases.' . $strategy, $strategy);
        }

        if (class_exists($strategy) && is_a($strategy, DeleteConditionStrategyInterface::class, true)) {
            return $strategy;
        }

        $strategy = $this->prefixDeleteConditionStrategyNamespace($strategy);

        if (class_exists($strategy) && is_a($strategy, DeleteConditionStrategyInterface::class, true)) {
            return $strategy;
        }

        throw new UnexpectedValueException(
            "Could not resolve strategy '{$originalStrategy}' as a DeleteConditionStrategy"
        );
    }

    /**
     * @param string $class
     * @return string
     */
    protected function prefixDeleteConditionStrategyNamespace($class)
    {
        return rtrim(config('cms-models.strategies.delete.default-condition-namespace'), '\\') . '\\' . $class;
    }

    /**
     * @return string
     */
    protected function getUnmetConditionMessageForAuthorizationFailure()
    {
        return cms_trans('models.delete.failure.not-authorized');
    }

    /**
     * @return string
     */
    protected function getUnmetConditionMessageForDisallowedFailure()
    {
        return cms_trans('models.delete.failure.disallowed');
    }

    /**
     * Returns whether models may be deleted unconditionally.
     *
     * @return bool
     */
    protected function isUnconditionallyDeletable()
    {
        return (    $this->getModelInformation()->allowDelete()
                &&  false === $this->getModelInformation()->deleteCondition()
                );
    }


    /**
     * @return string
     */
    abstract protected function getPermissionPrefix();

    /**
     * @return ModelInformationInterface
     */
    abstract protected function getModelInformation();

}
