<?php
namespace Czim\CmsModels\Http\Controllers\Traits;

use Czim\CmsCore\Contracts\Auth\UserInterface;
use Czim\CmsModels\Contracts\Data\ModelInformationInterface;
use Czim\CmsModels\Contracts\Repositories\DeleteConditionStrategyInterface;
use Illuminate\Database\Eloquent\Model;

trait ChecksModelDeletable
{

    /**
     * A (translated) message generated by the last unmet delete condition.
     *
     * @var null|string
     */
    protected $lastUnmetDeleteConditionMessage;

    /**
     * Returns whether a given model may be deleted.
     *
     * @param Model $model
     * @return bool
     */
    protected function isModelDeletable(Model $model)
    {
        $this->lastUnmetDeleteConditionMessage = null;

        // access rights
        if ( ! $this->isAuthorizedToDelete()) {
            $this->lastUnmetDeleteConditionMessage = $this->getUnmetConditionMessageForAuthorizationFailure();
            return false;
        }

        // delete condition & model configuration
        $info = $this->getModelInformation();

        if ( ! $info->allowDelete()) {
            $this->lastUnmetDeleteConditionMessage = $this->getUnmetConditionMessageForDisallowedFailure();
            return false;
        }

        $condition = $info->deleteCondition();

        if ( ! $condition) {
            return true;
        }

        // Resolve condition and check.
        $strategies = $this->interpretDeleteCondition($condition);

        foreach ($strategies as $strategy => $parameters) {

            /** @var DeleteConditionStrategyInterface $instance */
            $instance = app($strategy);

            if ( ! $instance->check($model)) {
                $this->lastUnmetDeleteConditionMessage = $instance->message();
                return false;
            }
        }

        return true;
    }

    /**
     * Returns whether (current) user is allowed to delete a model.
     *
     * @param UserInterface|null $user      uses logged in user by default
     * @return bool
     */
    protected function isAuthorizedToDelete(UserInterface $user = null)
    {
        $user = $user ?: cms_auth()->user();

        return $user->can($this->getPermissionPrefix() . 'delete');
    }

    /**
     * Returns the failure display message for the previous delete condition check.
     *
     * @return null|string
     */
    protected function getLastUnmetDeleteConditionMessage()
    {
        return $this->lastUnmetDeleteConditionMessage;
    }

    /**
     * Interprets delete condition value and returns an array of delete condition classes
     *
     * @param $condition
     * @return array    associative: returns key-value pairs: 'strategy' => parameters
     */
    protected function interpretDeleteCondition($condition)
    {
        // Normalize arrays, handle each string condition separately
        if (is_array($condition)) {

            $normalized = [];

            foreach ($condition as $partialCondition) {

                $normalized[] = $this->interpretDeleteCondition($partialCondition);
            }

            return $normalized;
        }

        // Split strategy & parameters
        if (false !== strpos($condition, ':')) {
            list($strategy, $parameters) = explode(':', $condition, 2);
        } else {
            $strategy   = $condition;
            $parameters = [];
        }

        $strategy = $this->resolveDeleteConditionStrategyClass($strategy);

        if (false === $strategy) {
            throw new \UnexpectedValueException(
                "Could not resolve strategy '{$strategy}' as a DeleteConditionStrategy"
            );
        }

        return [ $strategy => $parameters ];
    }

    /**
     * Resolves strategy assuming it is the class name or FQN of a delete condition interface
     * implementation, or a configured alias.
     *
     * @param string $strategy
     * @return string|false     returns full class namespace if it was resolved succesfully
     */
    protected function resolveDeleteConditionStrategyClass($strategy)
    {
        if ( ! str_contains($strategy, '.')) {
            $strategy = config('cms-models.strategies.delete.aliases.' . $strategy, $strategy);
        }

        if (class_exists($strategy) && is_a($strategy, DeleteConditionStrategyInterface::class, true)) {
            return $strategy;
        }

        $strategy = $this->prefixDeleteStrategyNamespace($strategy);

        if (class_exists($strategy) && is_a($strategy, DeleteConditionStrategyInterface::class, true)) {
            return $strategy;
        }

        return false;
    }

    /**
     * @param string $class
     * @return string
     */
    protected function prefixDeleteStrategyNamespace($class)
    {
        return rtrim(config('cms-models.strategies.delete.default-namespace'), '\\') . '\\' . $class;
    }

    /**
     * @return string
     */
    protected function getUnmetConditionMessageForAuthorizationFailure()
    {
        return cms_trans('models.delete.unmet.not-authorized');
    }

    /**
     * @return string
     */
    protected function getUnmetConditionMessageForDisallowedFailure()
    {
        return cms_trans('models.delete.unmet.disallowed');
    }


    /**
     * @return string
     */
    abstract protected function getPermissionPrefix();

    /**
     * @return ModelInformationInterface
     */
    abstract protected function getModelInformation();

}
